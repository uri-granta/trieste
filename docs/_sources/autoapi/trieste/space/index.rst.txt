:mod:`trieste.space`
====================

.. py:module:: trieste.space

.. autoapi-nested-parse::

   This module contains implementations of various types of search space. 



Module Contents
---------------

.. data:: SP
   

   A type variable bound to :class:`SearchSpace`. 


.. class:: SearchSpace

   Bases: :py:obj:`abc.ABC`

   A :class:`SearchSpace` represents the domain over which an objective function is optimized.

   .. method:: sample(self, num_samples: int) -> trieste.type.TensorType
      :abstractmethod:

      :param num_samples: The number of points to sample from this search space.
      :return: ``num_samples`` i.i.d. random points, sampled uniformly from this search space.


   .. method:: __contains__(self, value: trieste.type.TensorType) -> bool | TensorType
      :abstractmethod:

      :param value: A point to check for membership of this :class:`SearchSpace`.
      :return: `True` if ``value`` is a member of this search space, else `False`. May return a
          scalar boolean `TensorType` instead of the `bool` itself.
      :raise ValueError (or InvalidArgumentError): If ``value`` has a different dimensionality
          from this :class:`SearchSpace`.


   .. method:: __mul__(self: SP, other: SP) -> SP
      :abstractmethod:

      :param other: A search space of the same type as this search space.
      :return: The Cartesian product of this search space with the ``other``.


   .. method:: __pow__(self: SP, other: int) -> SP

      Return the Cartesian product of ``other`` instances of this search space. For example, for
      an exponent of `3`, and search space `s`, this is `s ** 3`, which is equivalent to
      `s * s * s`.

      :param other: The exponent, or number of instances of this search space to multiply
          together. Must be strictly positive.
      :return: The Cartesian product of ``other`` instances of this search space.
      :raise ValueError: If the exponent ``other`` is less than 1.



.. class:: DiscreteSearchSpace(points: trieste.type.TensorType)


   Bases: :py:obj:`SearchSpace`

   A discrete :class:`SearchSpace` representing a finite set of :math:`D`-dimensional points in
   :math:`\mathbb{R}^D`.

   For example:

       >>> points = tf.constant([[-1.0, 0.4], [-1.0, 0.6], [0.0, 0.4]])
       >>> search_space = DiscreteSearchSpace(points)
       >>> assert tf.constant([0.0, 0.4]) in search_space
       >>> assert tf.constant([1.0, 0.5]) not in search_space


   :param points: The points that define the discrete space, with shape ('N', 'D').
   :raise ValueError (or InvalidArgumentError): If ``points`` has an invalid shape.

   .. method:: points(self) -> trieste.type.TensorType
      :property:

      All the points in this space. 


   .. method:: __contains__(self, value: trieste.type.TensorType) -> bool | TensorType

      :param value: A point to check for membership of this :class:`SearchSpace`.
      :return: `True` if ``value`` is a member of this search space, else `False`. May return a
          scalar boolean `TensorType` instead of the `bool` itself.
      :raise ValueError (or InvalidArgumentError): If ``value`` has a different dimensionality
          from this :class:`SearchSpace`.


   .. method:: sample(self, num_samples: int) -> trieste.type.TensorType

      :param num_samples: The number of points to sample from this search space.
      :return: ``num_samples`` i.i.d. random points, sampled uniformly, and without replacement,
          from this search space.


   .. method:: __mul__(self, other: DiscreteSearchSpace) -> DiscreteSearchSpace

      Return the Cartesian product of the two :class:`DiscreteSearchSpace`\ s. For example:

          >>> sa = DiscreteSearchSpace(tf.constant([[0, 1], [2, 3]]))
          >>> sb = DiscreteSearchSpace(tf.constant([[4, 5, 6], [7, 8, 9]]))
          >>> (sa * sb).points.numpy()
          array([[0, 1, 4, 5, 6],
                 [0, 1, 7, 8, 9],
                 [2, 3, 4, 5, 6],
                 [2, 3, 7, 8, 9]], dtype=int32)

      :param other: A :class:`DiscreteSearchSpace` with :attr:`points` of the same dtype as this
          search space.
      :return: The Cartesian product of the two :class:`DiscreteSearchSpace`\ s.
      :raise TypeError: If one :class:`DiscreteSearchSpace` has :attr:`points` of a different
          dtype to the other.



.. class:: Box(lower: Sequence[float], upper: Sequence[float])
           Box(lower: trieste.type.TensorType, upper: trieste.type.TensorType)

   Bases: :py:obj:`SearchSpace`

   Continuous :class:`SearchSpace` representing a :math:`D`-dimensional box in
   :math:`\mathbb{R}^D`. Mathematically it is equivalent to the Cartesian product of :math:`D`
   closed bounded intervals in :math:`\mathbb{R}`.

   If ``lower`` and ``upper`` are `Sequence`\ s of floats (such as lists or tuples),
   they will be converted to tensors of dtype `tf.float64`.

   :param lower: The lower (inclusive) bounds of the box. Must have shape [D] for positive D,
       and if a tensor, must have float type.
   :param upper: The upper (inclusive) bounds of the box. Must have shape [D] for positive D,
       and if a tensor, must have float type.
   :raise ValueError (or InvalidArgumentError): If any of the following are true:

       - ``lower`` and ``upper`` have invalid shapes.
       - ``lower`` and ``upper`` do not have the same floating point type.
       - ``upper`` is not greater than ``lower`` across all dimensions.

   .. method:: lower(self) -> trieste.type.TensorType
      :property:

      The lower bounds of the box. 


   .. method:: upper(self) -> trieste.type.TensorType
      :property:

      The upper bounds of the box. 


   .. method:: __contains__(self, value: trieste.type.TensorType) -> bool | TensorType

      Return `True` if ``value`` is a member of this search space, else `False`. A point is a
      member if all of its coordinates lie in the closed intervals bounded by the lower and upper
      bounds.

      :param value: A point to check for membership of this :class:`SearchSpace`.
      :return: `True` if ``value`` is a member of this search space, else `False`. May return a
          scalar boolean `TensorType` instead of the `bool` itself.
      :raise ValueError (or InvalidArgumentError): If ``value`` has a different dimensionality
          from the search space.


   .. method:: sample(self, num_samples: int) -> trieste.type.TensorType

      :param num_samples: The number of points to sample from this search space.
      :return: ``num_samples`` i.i.d. random points, sampled uniformly from this search space.


   .. method:: discretize(self, num_samples: int) -> DiscreteSearchSpace

      :param num_samples: The number of points in the :class:`DiscreteSearchSpace`.
      :return: A discrete search space consisting of ``num_samples`` points sampled uniformly from
          this :class:`Box`.


   .. method:: __mul__(self, other: Box) -> Box

      Return the Cartesian product of the two :class:`Box`\ es (concatenating their respective
      lower and upper bounds). For example:

          >>> unit_interval = Box([0.0], [1.0])
          >>> square_at_origin = Box([-2.0, -2.0], [2.0, 2.0])
          >>> new_box = unit_interval * square_at_origin
          >>> new_box.lower.numpy()
          array([ 0., -2., -2.])
          >>> new_box.upper.numpy()
          array([1., 2., 2.])

      :param other: A :class:`Box` with bounds of the same type as this :class:`Box`.
      :return: The Cartesian product of the two :class:`Box`\ es.
      :raise TypeError: If the bounds of one :class:`Box` have different dtypes to those of
          the other :class:`Box`.



